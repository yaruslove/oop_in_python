'''
На этом занятии мы затронем довольно интересную, 
но не простую тему – дескрипторов классов. 
Я начну с одного явного недостатка объектов-свойств,
о которых мы с вами уже подробно говорили. 
Давайте представим, что создаем класс для представления 
точек в трехмерном пространстве: 
'''

class Point3D:
    def __init__(self, x, y, z):
        self._x = x
        self._y = y
        self._z = z

# '''
# Здесь у нас формируются защищенные локальные свойства
# для создаваемого объекта класса Point3D.
# Теперь представим, что согласно заданию координаты
# должны представляться исключительно целыми числами. 
# Для этого я пропишу следующий метод проверки: 
# '''
    
    @classmethod
    def verify_coord(cls, coord):
        if type(coord) != int:
            raise TypeError("Координата должна быть целым числом")

# А вызывать его будут в сеттерах соответствующих свойств класса: 
    @property
    def x(self):
        return self._x
 
    @x.setter
    def x(self, coord):
        self.verify_coord(coord)
        self._x = coord
 
    @property
    def y(self):
        return self._y
 
    @y.setter
    def y(self, coord):
        self.verify_coord(coord)
        self._y = coord
 
    @property
    def z(self):
        return self._z
 
    @z.setter
    def z(self, coord):
        self.verify_coord(coord)
        self._z = coord


'''
Но, смотрите, в нашем классе Point3D 
получилось своеобразное дублирование: 
мы три раза прописывали свойства, фактически, 
с одинаковым функционалом. 
Менялись только названия методов и локальных атрибутов. 
Представьте, во что превратится описание этого класса, 
если нужно будет задать 10 и более таких объектов-свойств! 
Программист во всем этом просто запутается, да и редактировать
такую программу станет непросто. Как можно все это оптимизировать? 
Здесь нам на помощь как раз и приходят дескрипторы. 
'''

'''
Вначале, что вообще такое дескрипторы? 
Это класс, который содержит или один магический метод __get__: 

class A:
    def __get__(self, instance, owner): 
        return ...


Или класс, в котором дополнительно прописаны методы __set__ и/или __del__:

class B:
    def __get__(self, instance, owner):
        return ...
 
    def __set__(self, instance, value):
        ...
 
    def __del__(self):
        ...

Первый (класс A) называется non-data descriptor 
(дескриптор не данных), 
а второй (класс B) – data descriptor (дескриптор данных).
Это различие имеет смысл, но об этом позже.

Как вы уже догадались, эти магические методы, 
по сути, геттеры и сеттеры, 
а также делитер. Давайте, теперь посмотрим, 
как дескриптор может упростить 
наш программный код с обработкой координат точек.

Вначале я покажу все взаимодействие на схеме. 
Так как все координаты – целые числа, то интерфейс взаимодействия
с ними мы определим через дескриптор с названием 
Integer (это имя мы, конечно же, придумываем сами): 
'''

class Integer:
    @classmethod
    def verify_coord(cls, coord):
        if type(coord) != int:
            raise TypeError("Координата должна быть целым числом")

    def __set_name__(self, owner, name):
        self.name = "_" + name
 
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]
 
    def __set__(self, instance, value):
        print(f"__set__: {self.name} = {value}")
        instance.__dict__[self.name] = value

'''
Пока не обращайте внимания на его содержимое, 
сейчас я все подробно объясню. 
Затем, в классе Point3D мы создадим 
три атрибута как объекты класса Integer: 
'''

class Point3D:
    x = Integer()
    y = Integer()
    z = Integer()
 
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z


'''
Эти атрибуты и есть дескрипторы данных, 
через которые будет проходить взаимодействие. 
Итак, когда мы создавали экземпляры классов Integer, 
то автоматически вызывался магический метод __set_name__, 
в котором параметр self являлся ссылкой на создаваемый экземпляр класса; 
owner – ссылка на класс Point3D; 
name – имя атрибута (для первого объекта x, затем, y и z). 
В этом методе мы формируем локальное свойство с именем атрибута, 
добавляя перед ним одно нижнее подчеркивание 
(так принято делать при определении дескрипторов). 
В итоге, в экземплярах классов будут храниться имена _x, _y, _z.
'''